How to code is an introductory course (two courses - but it's actually 1 course divided into 2 parts) about systematic program design. It assumes no background knowledge, and uses a simple teaching language, derived from Racket and the lisp-family languages.

There's a good reason why this is at the beginning of the OSSU "core programming" unit, after introduction to programming&computer science and before any courses that delve deeper into computer science - on the one hand, it uses a rather unconventional language, very different from the languages commonly used today, and doesn't even mention some core concepts used in almost all languages, such as variables and loops - at least not directly. This could confuse beginners who would only meet them later, in a course that assumes they already have some familiarity with those.
On the other hand, the concepts introduced in this course are not merely "important" - they are **crucial** to anyone who wants to be a good programmer, or more than that - a program designer.

What this course teaches is not language constructs, basic programming concepts or algorithms - Although it uses a great deal of recursion, and does a great job of explaining and applying it.
It teaches something that is often glossed over by self-taught programmers: systematic program design.
A better name for the course would have been "How To Design Programs"(which is the name of the book the course is based on), because that's what systematic program design is all about: how to plan out your programs before writing them, and during writing them, in order to ultimately arrive at a program that is better designed.  A good program is more than a program that just gets the job done - it is elegant, as simple as it can be, and efficient. Above all - it just **makes sense**. There's a natural flow from the problem requirement to the data definitions, to the function definitions and the rest of the program. It doesn't need as much comments as bad code because it almost reads itself. It is a kind of art.

This course's main forte is not in introducing the concepts of program design, but in doing it in a **systematic** way. It teaches a step-by-step process - a "design recipe" to designing data definitions and functions, which forces the learner to think about and understand the design required before writing the actual code. This way the learner eventually learns to view the code not as merely an incoherent mix of basic building blocks, but as something that goes from a certain point to another, with a defined shape that was made a certain way because it serves a purpose.
This is actually what one of the design steps - the template - is all about, but in a way that's what the whole recipe is about, what program design is about. Planning the program out, thinking about its structure, instead of just "coding away". When you design your programs this way, they tend to be simpler and more elegant, and sometimes even more efficient.
The way the design recipe works, by the time you get to the details of whatever problem you want to solve, you realise that you already know quite a lot about it. You can reduce a complex problem into a simple one, by realising what parts it is made of and how they interact to form together the desired outcome. It is often surprising how much you can accomplish this way. Systematic program design can easily be dismissed as a waste of time by someone who is not familiar with it, but it is well worth the effort - and this course does a great job of teaching it.

The course starts off slow, and a lot of learners think of dropping it during the first few weeks - but when it picks off steam, the payoff is great. Seemingly "boring" and "unimportant" concepts introduced earlier suddenly come together, helping form increasingly complex data and functions - thus demonstrating the power of systematic program design.

One thing I think the course is lacking in is demonstrating how the concepts taught in the course are applicable to other programming languages and paradigms. While I understand the course's motivation in not wanting to alienate people who are new to programming, I think not talking about those things hurts the transferability of the skills taught in the course. This is especially true because lisp-family languages are rather unique languages, and functional programming is not the most widely-used paradigm. Applying the skills and methods used here in other scenarios can prove difficult because of how different it feels. 
That being said, at the time of writing this I have yet to actually try applying those skills elsewhere - so it's more of a gut feeling, and maybe this is much less of a problem that it seems to be.

Overall, through, this is truly an amazing course!
I thoroughly enjoyed it, and I think (and hope) that it will have a great influence on the way I program from now on.